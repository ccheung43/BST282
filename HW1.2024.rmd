---
title: "HSPH BST 282 HW 1"
author: "Caitlin Cheung"
date: "2/11/24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_python("~/miniconda3/envs/hw1/bin/python")
```

### Finding the BST 282 directory

Once you log in to HPC, type `cd /shared/courseSharedFolders/133853/` to go to the BST 282 shared directory. This folder contains all of the data needed to complete this assignment. You can either use them in this directory as is, or you also create a soft link using `ln -s /shared/courseSharedFolders/133853 ~/share` to your own private directory.

### Install Miniconda

The HPC lauches Spack softwares. I will provide some information on Spack if you have interested in this system. However, it might be easier to use conda environment for computational analysis. To set up your conda envrionment, please use the following commands in your terminal:

```         
$ srun --pty bash
$ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
$ bash Miniconda3-latest-Linux-x86_64.sh
```

Then you need to restart the terminal and your conda environment should be activated. Then, you are able to create new environment and install required packages(with specific versions) by yourself for the analysis.

### Problem 1: STAR alignment

We will give you a simple example to test high throughput sequencing alignment for RNA-seq data. Normally for paired-end sequencing data, each sample will have two separate FASTQ files, with line-by-line correspondence to the two reads from the same fragment. Read mapping could take a long time, so we have created just two FASTQ files of one RNA-seq sample with only 30,000 fragments (2 \* 30,000 reads, since they are paired-end) for you to run STAR instead of the full data. The mapping will generate one single output file.

**Use STAR (Dobin et al, Bioinformatics 2012) to map the reads to the reference genome, available on HPC at index inside the courseSharedFolders. Use the paired-end alignment mode and generate the output in SAM format.**

**Please include the full STAR report (the file summarizing the number of mappable reads). How many reads are mappable and how many are uniquely mappable? Here, mappable reads consists of uniquely mappable reads, reads mapped to multiple loci, and reads mapped to too many loci.**

```         
Sequencing data:
/shared/courseSharedFolders/133853/HW1/raw_data1

module: star=2.7.10b
index:/shared/courseSharedFolders/133853/HW1/index/star_index
```

```{r q1, engine="bash", eval=FALSE}
# conda install -c bioconda star=2.7.10b

# Define paths
star_index="/shared/courseSharedFolders/133853/HW1/index/star_index"
fastq="/shared/courseSharedFolders/133853/HW1/raw_data1"
output_dir="/shared/home/cac8967/HW1/STAR"
reference_fa="/shared/courseSharedFolders/133853/HW1/reference/Homo_sapiens.GRCh38.dna.primary_assembly.fa"
reference_gtf="/shared/courseSharedFolders/133853/HW1/reference/Homo_sapiens.GRCh38.108.gtf"

# Run STAR command
STAR --genomeDir "${star_index}" --readFilesIn "${fastq}/subA_l.fastq" "${fastq}/subA_r.fastq" --outSAMtype SAM --outFileNamePrefix "${output_dir}/star" --sjdbGTFfile "${reference_gtf}"

```

```{r, engine="bash", echo=FALSE}

# Read STAR report
star_report="/shared/home/cac8967/HW1/STAR/starLog.final.out"

# Print STAR report
cat "${star_report}"

uniquely_mapped=$(grep "Uniquely mapped reads number" "${star_report}" | awk '{print $NF}')
multiple_loci_mapped=$(grep "Number of reads mapped to multiple loci" "${star_report}" | awk '{print $NF}')
too_many_loci_mapped=$(grep "Number of reads mapped to too many loci" "${star_report}" | awk '{print $NF}')

total_mapped=$((uniquely_mapped + multiple_loci_mapped + too_many_loci_mapped))

echo "Mappable Reads: ${total_mapped}"
echo "Uniquely Mappable Reads: ${uniquely_mapped}"
```

There are 28272 mappable reads and 19292 uniquely mappable reads.

### Problem 2: RNA-seq quality control

You are asked by a collaborator to analyze four RNA-seq libraries. She suspects that the libraries are generally of high-quality but is concerned that a sample may have been switched with her benchmates during processing. To save time, we have provided four bam files generated by STAR.

**Please use RSeQC (Liguo Wang et al, Bioinformatics 2012) geneBody_coverage.py and tin.py modules to determine whether any of the samples exhibit unusual quality control metrics. To expedite the process, you can use housekeeping genes as reference, which are provided in /shared/courseSharedFolders/133853/HW1/raw_data2. Overall, identify the best and worst libraries. Your answer should include figures and tables as would be necessary if you were delivering a report to the collaborator.**

```         
data: 
/shared/courseSharedFolders/133853/HW1/raw_data2/bamFile

module: rseqc, samtools
```

```{r q2, engine="bash", eval=FALSE}
# pip install rseqc
# conda install -c bioconda samtools

# define paths
bam_folder="/shared/courseSharedFolders/133853/HW1/raw_data2/bamFile"
housekeeping_genes="/shared/courseSharedFolders/133853/HW1/raw_data2/hg38.HouseKeepingGenes.nochr.bed"
sorted_bam_folder="/shared/home/cac8967/HW1/sortedBamFile"
output_dir="/shared/home/cac8967/HW1/RSEQC"

# sort bam files 
for bam_file in "$bam_folder"/*.bam; do
    file_name=$(basename -- "$bam_file")
    file_name_no_ext="${file_name%.bam}"
    samtools sort "$bam_file" -o "$sorted_bam_folder/${file_name_no_ext}_sorted.bam"
    samtools index "$sorted_bam_folder/${file_name_no_ext}_sorted.bam"
done

# run geneBody_coverage.py to generate gene body coverage plots
geneBody_coverage.py -r "${housekeeping_genes}" -i "${sorted_bam_folder}"  -o "${output_dir}/output"

cd "${output_dir}"

# run tin.py to calculate the transcription integrity number (TIN) 
tin.py -i "${sorted_bam_folder}" -r "${housekeeping_genes}" 

```

```{r include_pdf, echo=FALSE}

knitr::include_graphics("/shared/home/cac8967/HW1/RSEQC/output.geneBodyCoverage.curves.pdf") 

knitr::include_graphics("/shared/home/cac8967/HW1/RSEQC/output.geneBodyCoverage.heatMap.pdf") 
```

```{r, echo = FALSE}
#Get file paths 
fileW = "/shared/home/cac8967/HW1/RSEQC/res_WAligned.sortedByCoord.out_sorted.summary.txt" 
fileX = "/shared/home/cac8967/HW1/RSEQC/res_XAligned.sortedByCoord.out_sorted.summary.txt" 
fileY = "/shared/home/cac8967/HW1/RSEQC/res_YAligned.sortedByCoord.out_sorted.summary.txt" 
fileZ = "/shared/home/cac8967/HW1/RSEQC/res_ZAligned.sortedByCoord.out_sorted.summary.txt" 

# Read the text files
file_names <- c(fileW, fileX, fileY, fileZ)

# Store as df
data_frames <- list()
for (file in file_names) {
  data_frames[[file]] <- read.table(file, header = TRUE, sep = "\t")
}

combined_df <- do.call(rbind, Map(cbind, data_frames, file = names(data_frames)))
combined_df <- combined_df[, -which(names(combined_df) == "file")]
row.names(combined_df) <- NULL

print(combined_df)
```

From the figures and table, we see that sample Y is the best library and sample Z is the worst library.

In the gene body coverage plot, we see that while Y has low gene body coverage at the very beginning and end, it has consistenty high coverage throughout the middle which is indicitave of a high quality sample. On the other hand, Z has varying gene body coverage throughout the entirety of the sample, which indicates it is a low quality sample. We see similar results in the gene body coverage heatmap, where there is a much greater proportion of pink coloring (denoting high gene coverage) in the Y sample than in the Z sample.

These results are confirmed by the tin output table where we see that the mean TIN value is highest in sample Y (mean.TIN = 56.20032) and lowest in sample Z (mean.TIN = 24.55179). Since TIN is the transcript integrity score measured from 0 to 100, a higher mean TIN value indicates a higher quality sample.

### Problem 3: Python programming

**One output of RSeQC is geneBodyCoverage.txt, which contains the normalized reads mapped to each % of the gene/transcript body. Write a Python script to extract the data from this file and make the gene body coverage diagram for all four samples. The figures for each sample should be arranged in a 2x2 grid (that is, two rows and two columns). An example of the desired output will be provided in the lecture video. As in problem 2, comment on which sample has the worst quality.**

```{python q3}
# import packages
import pandas as pd
import matplotlib.pyplot as plt

# read in file
data = pd.read_csv('/shared/home/cac8967/HW1/RSEQC/output.geneBodyCoverage.txt', sep='\t', index_col='Percentile')
data = data.transpose()

# extract data sections
percentile = data.index.astype(float)
sampleW = data['res_WAligned.sortedByCoord.out_sorted']
sampleX = data['res_XAligned.sortedByCoord.out_sorted']
sampleY = data['res_YAligned.sortedByCoord.out_sorted']
sampleZ = data['res_ZAligned.sortedByCoord.out_sorted']

# Create a 2x2 subplot grid
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))

# Plot for Sample W
axes[0, 0].plot(percentile, sampleW, label='Sample W')
axes[0, 0].set_xlabel('Percentile')
axes[0, 0].set_ylabel('Gene Body Coverage')
axes[0, 0].set_title('Sample W')
axes[0, 0].legend()

# Plot for Sample X
axes[0, 1].plot(percentile, sampleX, label='Sample X')
axes[0, 1].set_xlabel('Percentile')
axes[0, 1].set_ylabel('Gene Body Coverage')
axes[0, 1].set_title('Sample X')
axes[0, 1].legend()

# Plot for Sample Y
axes[1, 0].plot(percentile, sampleY, label='Sample Y')
axes[1, 0].set_xlabel('Percentile')
axes[1, 0].set_ylabel('Gene Body Coverage')
axes[1, 0].set_title('Sample Y')
axes[1, 0].legend()

# Plot for Sample Z
axes[1, 1].plot(percentile, sampleZ, label='Sample Z')
axes[1, 1].set_xlabel('Percentile')
axes[1, 1].set_ylabel('Gene Body Coverage')
axes[1, 1].set_title('Sample Z')
axes[1, 1].legend()

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()
```

From these plots, it is again clear that sample Z has the worst quality whereas samples W, X, and Y have higher quality. W, X, and Y have consistently high coverage throughout the middle of the samples which is indicative of high quality samples. However, we see that Z has varying gene body coverage throughout the entirety of the sample, which indicates it is a low quality sample.

### Problem 4: RNA-seq quantification

Transcript quantification plays an important role in the analysis of RNA-seq data. A large number of tools have been developed to quantify expression at the transcript level. RSEM (Bo Li et al, BMC Bioinformatics 2011) is a software package for estimating gene and isoform expression levels from single-end or paired-end RNA-Seq data, it can perform the alignment step with three different aligners: bowtie, bowtie2, or STAR. Salmon (Rob Patro et al, Nature Methods 2017) is an ultra-fast alignment-free method which also can correct for GC-bias.

**Please run STAR+RSEM and Salmon on one good quality sample from problem 2 and 3 to get FPKM and TPM for this sample. Identify the transcript and gene with the highest expression in this library from the Salmon output (please provide the gene symbol, not just an ENSEMBL ID). Submit the batch script used to obtain the results.**

```         
data: /shared/courseSharedFolders/133853/HW1/raw_data2
module: rsem=1.3.3, salmon=1.10.2

index: 
/shared/courseSharedFolders/133853/HW1/index/salmon_index
/shared/courseSharedFolders/133853/HW1/index/rsem_index
```

```{r q4, engine="bash", eval=FALSE}
# your bash code here

# conda install -c bioconda rsem=1.3.3
# conda install -c bioconda salmon=1.10.2

fastq="/shared/courseSharedFolders/133853/HW1/raw_data2/fastqFile/runY.fastq.gz"
output_dir="/shared/home/cac8967/HW1" 
star_index="/shared/courseSharedFolders/133853/HW1/index/star_index"
rsem_index="/shared/courseSharedFolders/133853/HW1/index/rsem_index"
salmon_index="/shared/courseSharedFolders/133853/HW1/index/salmon_index"


# Run STAR
STAR --runThreadN 8 --genomeDir "${star_index}" --readFilesCommand zcat --readFilesIn "${fastq}" --outSAMtype BAM SortedByCoordinate --quantMode TranscriptomeSAM --outFileNamePrefix "${output_dir}/STAR_output/run"

# Run RSEM
rsem-calculate-expression --bam -p 8 --alignments "${output_dir}/STAR_output/runAligned.toTranscriptome.out.bam" "${rsem_index}/rsem" "${output_dir}/RSEM_output/run"

# Run Salmon
salmon quant -i "${salmon_index}" -l A -r "${fastq}" -p 8 --validateMappings -o "${output_dir}/Salmon_output"

```

```{r}
quant_file <- "/shared/home/cac8967/HW1/Salmon_output/quant.sf"
quant_data <- read.table(quant_file, header = TRUE, sep = "\t")
quant_sorted <- quant_data[order(quant_data$TPM, decreasing = TRUE), ]

highest_expression_transcript <- quant_sorted$Name[1]

print(highest_expression_transcript)
```

By sorting the salmon quant.sf output file by TPM, we find that the transcript with the greatest TPM value, and this the highest expression is ENST00000361851.1 which corresponds to the gene symbol MT-ATP8.

### Problem 5: Speed Comparison

**Report the run-time for STAR+RSEM and Salmon from the previous question. You do not need to submit any code, but you should explain how you found the run-time. Comment on your results based on the lecture material.**

STAR + RSEM = (0m59.050s) + (5m37.161s) = 6m36.211s

Salmon = 0m37.933s

To get these runtimes, I ran the bash command "time" followed by the corresponding STAR, RSEM, or Salmon line. After these commands ran, the "real time" runtimes were outputted. For STAR + RSEM, I added the runtime of STAR and the runtime of RSEM together since they must run sequentially.

Based on the results, Salmon had a much faster runtime than STAR + RSEM when each were run on 8 threads. This makes sense because STAR is an aligner whereas Salmon is only a pseudoaligner. While STAR aligns each read individually, Salmon uses the de Bruijn graph which speeds up the process, producing faster runtimes.

### Problem 6:

**First create a heatmap that summarizes the correlation between effective length, normalized read counts, TPM, and FPKM for either Salmon or RSEM. Comment on the relative utility of each metric when analyzing gene expression. Next, directly compare the output of both Salmon and RSEM. Do the results agree between the two methods?**

```{r q6}
# your R code here

S <- read.table('/shared/home/cac8967/HW1/Salmon_output/quant.sf',header = TRUE, sep="\t")
dataS <- data.frame(Length_S = S$EffectiveLength, 
                    Counts_S = S$NumReads, 
                    TPM_S = S$TPM, 
                    FPKM_S = (S$TPM * 10^6) / (S$EffectiveLength / 1000), 
                    name = sub("\\..*", "", S$Name))

R <- read.table('/shared/home/cac8967/HW1/RSEM_output/run.isoforms.results',header = TRUE, sep="\t")
dataR <- data.frame(Length_R = R$effective_length, 
                    Counts_R = R$expected_count, 
                    TPM_R = R$TPM, 
                    FPKM_R = R$FPKM, 
                    name = R$transcript_id) 

dataSR <- merge(dataS, dataR, by = "name")

dataS <- subset(dataS, select = -name)
dataR <- subset(dataR, select = -name)
dataSR <- subset(dataSR, select = -name)

correlations_SS <- cor(dataS)
correlations_RR <- cor(dataR)
correlations_SR <- cor(dataSR)
correlations_SR <- correlations_SR[1:4, 5:8]

```

```{r, eval=FALSE}
# create heatmaps
heatmap(correlations_SS, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "Salmon vs Salmon")

heatmap(correlations_RR, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "RSEM vs RSEM") 

heatmap(correlations_SR, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "Salmon vs RSEM") 

```

```{r, echo=FALSE}
# create heatmaps
heatmap(correlations_SS, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "Salmon vs Salmon")

heatmap(correlations_RR, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "RSEM vs RSEM") 

heatmap(correlations_SR, 
        col = colorRampPalette(c("blue", "white", "red"))(100), 
        symm = TRUE,  
        scale = "none", 
        cexRow = 1,
        cexCol = 1, 
        main = "Salmon vs RSEM") 
```

While effective length and normalized read counts can be used to assess gene expression, TPM and FPKM are more useful because they normalize reads based on both coverage and gene length so they can gauge the relative expression levels within a sample. TPM has the highest utility because it further divides by a scaling factor which can compare expression levels between samples, even if they are of differing lengths.

In the above heatmaps, we can compare effective length, normalized read counts, TPM, and FPKM between Salmon and RSEM:

Within Salmon, there is a strong positive correlation between TPM and FPKM and a strong negative relationship between TPM or FPKM and effective length. Effective length and FPKM are strongly negatively correlated with normalized read counts, whereas the correlation between TPM and normalized read counts is weak.

Within RSEM, there are strong positive correlations between TPM, FPKM, and normalized read counts, which each have a strong neative correlation with effective length.

Between Salmon and RSEM, their TPMs are weakly correlated while their FPKMs are strongly negatively correlated, indicating that Salmon and RSEM have different methods of calculating and reporting these metrics. Counts and lengths are strongly positively correlated, which makes sense given that they are based on the same transcripts.
